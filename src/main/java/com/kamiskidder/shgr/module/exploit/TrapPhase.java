package com.kamiskidder.shgr.module.exploit;

import com.kamiskidder.shgr.module.Category;
import com.kamiskidder.shgr.module.Module;
import com.kamiskidder.shgr.module.Setting;
import com.kamiskidder.shgr.util.entity.EntityUtil;
import com.kamiskidder.shgr.util.player.BlockUtil;
import com.kamiskidder.shgr.util.player.InventoryUtil;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;

public class TrapPhase extends Module {
    public Setting<Float> offset = register(new Setting("Offset", 0.2f, 1.0f, 0.0f));
    public Setting<Boolean> silentSwitch = register(new Setting("SilentSwitch", true));
    public Setting<Boolean> packetPlace = register(new Setting("PacketPlace", true));
    private EnumHand oldhand = null;
    private int oldslot = -1;

    public TrapPhase() {
        super("TrapPhase", Category.EXPLOIT);
    }

    @Override
    public void onTick() {
        if (nullCheck()) return;

        int slot = InventoryUtil.getBlockHotbar(Blocks.IRON_TRAPDOOR);
        if (slot == -1) {
            this.sendMessage("Cannot find materials! disabling");
            this.disable();
            return;
        }
        BlockPos[] offsets = new BlockPos[]{
                new BlockPos(1, 0, 0),
                new BlockPos(-1, 0, 0),
                new BlockPos(0, 0, 1),
                new BlockPos(0, 0, -1)
        };

        BlockPos playerPos = EntityUtil.getEntityPos(TrapBurrow.mc.player);
        BlockPos trappos = null;
        for (BlockPos offset : offsets) {
            BlockPos pos = playerPos.add(offset);
            if (!this.entityCheck(pos) || BlockUtil.getBlock(pos).equals(Blocks.AIR)) continue;
            trappos = pos;
        }
        if (trappos == null) {
            this.sendMessage("Cannot find space! disabling");
            this.disable();
            return;
        }
        this.setItem(slot);
        double x = TrapBurrow.mc.player.posX;
        double y = TrapBurrow.mc.player.posY;
        double z = TrapBurrow.mc.player.posZ;
        mc.player.connection.sendPacket(new CPacketPlayer.Position(x, y + this.offset.getValue(), z, TrapBurrow.mc.player.onGround));
        EnumFacing facing = null;
        for (EnumFacing f : EnumFacing.values()) {
            if (!trappos.add(f.getDirectionVec()).equals(playerPos)) continue;
            facing = f;
            break;
        }
        BlockUtil.rightClickBlock(trappos, facing, new Vec3d(0.5, 0.8, 0.5), this.packetPlace.getValue());
        TrapBurrow.mc.player.connection.sendPacket(new CPacketPlayer.Position(x, y, z, TrapBurrow.mc.player.onGround));
        this.restoreItem();
        this.disable();
    }
    public boolean entityCheck(BlockPos pos) {
        return mc.world.getEntitiesWithinAABB(Entity.class, new AxisAlignedBB(pos), e -> e instanceof EntityEnderCrystal || e instanceof EntityPlayer).isEmpty();
    }

    public void setItem(int slot) {
        if (silentSwitch.getValue()) {
            oldhand = null;
            if (mc.player.isHandActive()) oldhand = mc.player.getActiveHand();
            oldslot = mc.player.inventory.currentItem;
            mc.player.connection.sendPacket(new CPacketHeldItemChange(slot));
        } else {
            mc.player.inventory.currentItem = slot;
            mc.playerController.updateController();
        }
    }

    public void restoreItem() {
        if (oldslot != -1 && silentSwitch.getValue()) {
            if (oldhand != null) mc.player.setActiveHand(oldhand);
            mc.player.connection.sendPacket(new CPacketHeldItemChange(oldslot));
            oldslot = -1;
            oldhand = null;
        }
    }
}
