package com.kamiskidder.shgr.module.exploit;

import com.kamiskidder.shgr.event.player.PlayerDamageBlockEvent;
import com.kamiskidder.shgr.module.Category;
import com.kamiskidder.shgr.module.Module;
import com.kamiskidder.shgr.module.Setting;
import com.kamiskidder.shgr.util.client.Timer;
import com.kamiskidder.shgr.util.player.BlockUtil;
import com.kamiskidder.shgr.util.player.InventoryUtil;
import com.kamiskidder.shgr.util.render.RenderUtil;
import net.minecraft.block.Block;
import net.minecraft.init.Blocks;
import net.minecraft.init.Items;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.awt.*;
import java.util.Arrays;
import java.util.List;

public class InstantMine extends Module {
    private final Timer breakSuccess = new Timer();
    private final List<Block> godBlocks = Arrays.asList(Blocks.AIR, Blocks.FLOWING_LAVA, Blocks.LAVA, Blocks.FLOWING_WATER, Blocks.WATER, Blocks.BEDROCK);

    private final Setting<Boolean> creativeMode = register(new Setting("CreativeMode", Boolean.valueOf(true)));
    private final Setting<Boolean> ghostHand = register(new Setting("GhostHand", Boolean.valueOf(true), v -> this.creativeMode.getValue().booleanValue()));
    private final Setting<Boolean> render = register(new Setting("Render", Boolean.valueOf(true)));
    public Setting<String> mode = register(new Setting("Mode", "Fill", new String[]{"Fill", "Outline", "Both"}, v -> render.getValue()));
    public Setting<Color> color = register(new Setting("Color", new Color(230, 10, 10, 70), v -> !mode.getValue().equalsIgnoreCase("Outline") && render.getValue()));
    public Setting<Float> thickness = register(new Setting("Thickness", 1.5F, 5.0F, 0.1F, v -> !mode.getValue().equalsIgnoreCase("Fill") && render.getValue()));
    public Setting<Color> outlineColor = register(new Setting("Outline Color", new Color(255, 10, 10, 70), v -> !mode.getValue().equalsIgnoreCase("Fill") && render.getValue()));

    private boolean cancelStart = false;
    public BlockPos breakPos;
    private boolean empty = false;
    private EnumFacing facing;
    private boolean ghost = true;

    public InstantMine() {
        super("InstantMine", Category.EXPLOIT);
    }

    @Override
    public void onUpdate() {
        if (nullCheck())
            return;
        if (this.creativeMode.getValue() && this.cancelStart && !this.godBlocks.contains(mc.world.getBlockState(this.breakPos).getBlock()))
            if (this.ghostHand.getValue() && InventoryUtil.getItemHotbar(Items.DIAMOND_PICKAXE) != -1 && ghost) {
                int slotMain = mc.player.inventory.currentItem;
                if (mc.world.getBlockState(this.breakPos).getBlock() == Blocks.OBSIDIAN) {
                    if (this.breakSuccess.passedMs(1234L)) {
                        mc.player.connection.sendPacket(new CPacketHeldItemChange(InventoryUtil.getItemHotbar(Items.DIAMOND_PICKAXE)));
                        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.breakPos, this.facing));
                        mc.player.connection.sendPacket(new CPacketHeldItemChange(slotMain));
                    }
                } else {
                    mc.player.inventory.currentItem = InventoryUtil.getItemHotbar(Items.DIAMOND_PICKAXE);
                    mc.playerController.updateController();
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.breakPos, this.facing));
                    mc.player.inventory.currentItem = slotMain;
                    mc.playerController.updateController();
                }
            } else {
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.breakPos, this.facing));
            }
    }

    @Override
    public void onRender3D() {
        if (render.getValue() && breakPos != null) {
            RenderUtil.drawBox(breakPos, mode.getValue(), color.getValue(), outlineColor.getValue(), thickness.getValue());
        }
    }

    @SubscribeEvent
    public void onBlockEvent(PlayerDamageBlockEvent event) {
        if (nullCheck())
            return;
        if (BlockUtil.canBreak(event.pos)) {
            this.empty = false;
            this.cancelStart = false;
            this.breakPos = event.pos;
            this.breakSuccess.reset();
            this.facing = event.facing;
            if (this.breakPos != null) {
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, this.breakPos, this.facing));
                this.cancelStart = true;
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.breakPos, this.facing));
                event.setCanceled(true);
            }
        }
    }
}
